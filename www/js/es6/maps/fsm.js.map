{"version":3,"sources":["fsm.ts"],"names":[],"mappings":";;;;;;;;;;;YAMA;gBAQC,YAAY,KAAQ;oBAPZ,kBAAa,GAAW,IAAI,aAAM,EAAc,CAAA;oBAChD,gBAAW,GAA8B,EAAE,CAAA;oBAC3C,uBAAkB,GAAW,IAAI,aAAM,EAAc,CAAA;oBACrD,UAAK,GAAyB,EAAE,CAAA;oBAKvC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;gBACnB,CAAC;gBAGD,EAAE,CAAC,KAAQ,EAAE,OAAmB;oBAC/B,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAY,EAAE,OAAO,CAAC,CAAA;gBAC9C,CAAC;gBAID,GAAG,CAAC,MAAW,EAAE,KAAQ,EAAE,MAAS,EAAE,OAAoB;oBACzD,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,MAAM,CAAC,CAAC,CAAC;wBAC1B,MAAM,KAAK,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;wBACjD,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,MAAM,CAAA;wBAChC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;4BACb,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,CAAC,CAAA;wBAC5C,CAAC;oBACF,CAAC;gBACF,CAAC;gBAID,OAAO,CAAC,KAAQ,EAAE,MAAS,EAAE,OAAoB;oBAChD,IAAI,CAAC,KAAK,CAAC,KAAY,CAAC,GAAG,MAAM,CAAA;oBACjC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;wBACb,IAAI,CAAC,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA;oBACzB,CAAC;gBACF,CAAC;gBAGO,gBAAgB,CAAC,KAAQ,EAAE,KAAQ;oBAC1C,MAAM,CAAC,GAAG,KAAK,IAAI,KAAK,EAAE,CAAA;gBAC3B,CAAC;gBAGD,IAAI,CAAC,KAAQ,EAAE,GAAS;oBACvB,IAAI,MAAS,CAAA;oBACb,EAAE,CAAC,CAAC,KAAY,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;wBAChC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,KAAY,CAAC,CAAA;oBAClC,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACP,MAAM,KAAK,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;wBACtD,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAA;wBACrD,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;oBACjC,CAAC;oBACD,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,MAAa,EAAE,EAAE,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAA;oBACxD,IAAI,CAAC,KAAK,GAAG,MAAM,CAAA;gBACpB,CAAC;gBAID,MAAM,CAAC,KAAQ;oBACd,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,CAAA;gBACpC,CAAC;YACF,CAAC;YA9DD,yBA8DC,CAAA","file":"fsm.js","sourcesContent":["import {SetMap} from './util'\n\ntype ActHandler = (arg?: any) => void\ntype ActMap = SetMap<ActHandler>\n\n// Finite State Machine\nexport default class FSM<S, E> {\n\tprivate stateHandlers: ActMap = new SetMap<ActHandler>()\n\tprivate transitions: {[transition: string]: S} = {}\n\tprivate transitionHandlers: ActMap = new SetMap<ActHandler>()\n\tprivate wilds: {[event: string]: S} = {}\n\tstate: S\n\n\t// Create a new finite state machine with the supplied start state\n\tconstructor(start: S) {\n\t\tthis.state = start\n\t}\n\n\t// Assign a handler to be execute on arrival to a new state\n\ton(state: S, handler: ActHandler) {\n\t\tthis.stateHandlers.add(state as any, handler)\n\t}\n\n\t// Specify state transition and an optional handler to execute on it.\n\t// Any of starts[] + event -> result\n\tact(starts: S[], event: E, result: S, handler?: ActHandler) {\n\t\tfor (let start of starts) {\n\t\t\tconst trans = this.transitionString(start, event)\n\t\t\tthis.transitions[trans] = result\n\t\t\tif (handler) {\n\t\t\t\tthis.transitionHandlers.add(trans, handler)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Specify an event and optional handler, that will cause any state to\n\t// transition to the target result state.\n\twildAct(event: E, result: S, handler?: ActHandler) {\n\t\tthis.wilds[event as any] = result\n\t\tif (handler) {\n\t\t\tthis.on(result, handler)\n\t\t}\n\t}\n\n\t// Generate a transition string representation\n\tprivate transitionString(start: S, event: E): string {\n\t\treturn `${start}+${event}`\n\t}\n\n\t// Feed an event to the FSM\n\tfeed(event: E, arg?: any) {\n\t\tlet result: S\n\t\tif (event as any in this.wilds) {\n\t\t\tresult = this.wilds[event as any]\n\t\t} else {\n\t\t\tconst trans = this.transitionString(this.state, event)\n\t\t\tthis.transitionHandlers.forEach(trans, fn => fn(arg))\n\t\t\tresult = this.transitions[trans]\n\t\t}\n\t\tthis.stateHandlers.forEach(result as any, fn => fn(arg))\n\t\tthis.state = result\n\t}\n\n\t// Returns a function that executes FSM.prototype.feed with the suplied\n\t// argument\n\tfeeder(event: E): (arg?: any) => void {\n\t\treturn arg => this.feed(event, arg)\n\t}\n}\n"],"sourceRoot":"/source/"}