{"version":3,"sources":["fsm.js","fsm.ts"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","System","register","exports_1","context_1","util_1","id","setters","util_1_1","execute","FSM","start","this","stateHandlers","SetMap","transitions","transitionHandlers","wilds","state","value","handler","add","starts","event","result","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","trans","transitionString","err","on","arg","forEach","fn","_this","feed"],"mappings":"AAAA,YAIA,SAASA,iBAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAFhH,GAAIC,cAAe,WAAe,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeT,EAAQI,EAAWM,IAAKN,IAAiB,MAAO,UAAUR,EAAae,EAAYC,GAAiJ,MAA9HD,IAAYZ,EAAiBH,EAAYiB,UAAWF,GAAiBC,GAAab,EAAiBH,EAAagB,GAAqBhB,KAFjiBkB,QAAOC,UAAU,UAAW,SAASC,EAAWC,GAE5C,GACIC,EADeD,IAAaA,EAAUE,EAG1C,QACIC,SACI,SAAUC,GACNH,EAASG,IAEjBC,QAAS,WAOL,GCXZC,GAAA,WAQC,QARDA,GAQaC,GDKO9B,gBAAgB+B,KCbpCF,GACSE,KAAAC,cAAwB,GAAIR,GAAAS,OAC5BF,KAAAG,eACAH,KAAAI,mBAA6B,GAAIX,GAAAS,OACjCF,KAAAK,SAKPL,KAAKM,MAAQP,ED4FC,MA/EA1B,cCtBhByB,IDuBoBb,IAAK,KACLsB,MAAO,SCXvBD,EAAUE,GACZR,KAAKC,cAAcQ,IAAIH,EAAcE,MDcnBvB,IAAK,MACLsB,MAAO,SCVtBG,EAAaC,EAAUC,EAAWJ,GDWf,GAAIK,IAA4B,EAC5BC,GAAoB,EACpBC,EAAiBC,MAErB,KCdtB,IAAA,GAAwBC,GAAxBC,EAAkBR,EAAMS,OAAAC,cAAAP,GAAAI,EAAAC,EAAAG,QAAAC,MAAAT,GAAA,EAAE,CDgBI,GChBrBd,GAAKkB,EAAAV,MACPgB,EAAQvB,KAAKwB,iBAAiBzB,EAAOY,EAC3CX,MAAKG,YAAYoB,GAASX,EACtBJ,GACHR,KAAKI,mBAAmBK,IAAIc,EAAOf,IDoBb,MAAOiB,GACLX,GAAoB,EACpBC,EAAiBU,EACnB,QACE,KACSZ,GAA6BK,EAAAA,WAC9BA,EAAAA,YAEN,QACE,GAAIJ,EACA,KAAMC,QAMtB9B,IAAK,UACLsB,MAAO,SC9BlBI,EAAUC,EAAWJ,GAC5BR,KAAKK,MAAMM,GAAgBC,EACvBJ,GACHR,KAAK0B,GAAGd,EAAQJ,MDkCCvB,IAAK,mBACLsB,MAAO,SC9BDR,EAAUY,GAClC,MAAUZ,GAAK,IAAIY,KDiCD1B,IAAK,OACLsB,MAAO,SC9BrBI,EAAUgB,GACd,GAAIf,GAASI,MACb,IAAIL,IAAgBX,MAAKK,MACxBO,EAASZ,KAAKK,MAAMM,OACd,CACN,GAAMY,GAAQvB,KAAKwB,iBAAiBxB,KAAKM,MAAOK,EAChDX,MAAKI,mBAAmBwB,QAAQL,EAAO,SAAAM,GD+BV,MC/BgBA,GAAGF,KAChDf,EAASZ,KAAKG,YAAYoB,GAE3BvB,KAAKC,cAAc2B,QAAQhB,EAAe,SAAAiB,GDiChB,MCjCsBA,GAAGF,KACnD3B,KAAKM,MAAQM,KDqCK3B,IAAK,SACLsB,MAAO,SCjCnBI,GDkCgB,GAAImB,GAAQ9B,ICjClC,OAAO,UAAA2B,GDoCmB,MCpCZG,GAAKC,KAAKpB,EAAOgB,QA5DjC7B,IAAAP,GAAA,UAAAO","file":"fsm.js","sourcesContent":["System.register(['./util'], function(exports_1, context_1) {\n    \"use strict\";\n    var __moduleName = context_1 && context_1.id;\n    var util_1;\n    var FSM;\n    return {\n        setters:[\n            function (util_1_1) {\n                util_1 = util_1_1;\n            }],\n        execute: function() {\n            class FSM {\n                constructor(start) {\n                    this.stateHandlers = new util_1.SetMap();\n                    this.transitions = {};\n                    this.transitionHandlers = new util_1.SetMap();\n                    this.wilds = {};\n                    this.state = start;\n                }\n                on(state, handler) {\n                    this.stateHandlers.add(state, handler);\n                }\n                act(starts, event, result, handler) {\n                    for (let start of starts) {\n                        const trans = this.transitionString(start, event);\n                        this.transitions[trans] = result;\n                        if (handler) {\n                            this.transitionHandlers.add(trans, handler);\n                        }\n                    }\n                }\n                wildAct(event, result, handler) {\n                    this.wilds[event] = result;\n                    if (handler) {\n                        this.on(result, handler);\n                    }\n                }\n                transitionString(start, event) {\n                    return `${start}+${event}`;\n                }\n                feed(event, arg) {\n                    let result;\n                    if (event in this.wilds) {\n                        result = this.wilds[event];\n                    }\n                    else {\n                        const trans = this.transitionString(this.state, event);\n                        this.transitionHandlers.forEach(trans, fn => fn(arg));\n                        result = this.transitions[trans];\n                    }\n                    this.stateHandlers.forEach(result, fn => fn(arg));\n                    this.state = result;\n                }\n                feeder(event) {\n                    return arg => this.feed(event, arg);\n                }\n            }\n            exports_1(\"default\", FSM);\n        }\n    }\n});\n","import {SetMap} from './util'\n\ntype ActHandler = (arg?: any) => void\ntype ActMap = SetMap<ActHandler>\n\n// Finite State Machine\nexport default class FSM<S, E> {\n\tprivate stateHandlers: ActMap = new SetMap<ActHandler>()\n\tprivate transitions: {[transition: string]: S} = {}\n\tprivate transitionHandlers: ActMap = new SetMap<ActHandler>()\n\tprivate wilds: {[event: string]: S} = {}\n\tstate: S\n\n\t// Create a new finite state machine with the supplied start state\n\tconstructor(start: S) {\n\t\tthis.state = start\n\t}\n\n\t// Assign a handler to be execute on arrival to a new state\n\ton(state: S, handler: ActHandler) {\n\t\tthis.stateHandlers.add(state as any, handler)\n\t}\n\n\t// Specify state transition and an optional handler to execute on it.\n\t// Any of starts[] + event -> result\n\tact(starts: S[], event: E, result: S, handler?: ActHandler) {\n\t\tfor (let start of starts) {\n\t\t\tconst trans = this.transitionString(start, event)\n\t\t\tthis.transitions[trans] = result\n\t\t\tif (handler) {\n\t\t\t\tthis.transitionHandlers.add(trans, handler)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Specify an event and optional handler, that will cause any state to\n\t// transition to the target result state.\n\twildAct(event: E, result: S, handler?: ActHandler) {\n\t\tthis.wilds[event as any] = result\n\t\tif (handler) {\n\t\t\tthis.on(result, handler)\n\t\t}\n\t}\n\n\t// Generate a transition string representation\n\tprivate transitionString(start: S, event: E): string {\n\t\treturn `${start}+${event}`\n\t}\n\n\t// Feed an event to the FSM\n\tfeed(event: E, arg?: any) {\n\t\tlet result: S\n\t\tif (event as any in this.wilds) {\n\t\t\tresult = this.wilds[event as any]\n\t\t} else {\n\t\t\tconst trans = this.transitionString(this.state, event)\n\t\t\tthis.transitionHandlers.forEach(trans, fn => fn(arg))\n\t\t\tresult = this.transitions[trans]\n\t\t}\n\t\tthis.stateHandlers.forEach(result as any, fn => fn(arg))\n\t\tthis.state = result\n\t}\n\n\t// Returns a function that executes FSM.prototype.feed with the suplied\n\t// argument\n\tfeeder(event: E): (arg?: any) => void {\n\t\treturn arg => this.feed(event, arg)\n\t}\n}\n"],"sourceRoot":"/source/"}