{"version":3,"sources":["posts/render/body.js","posts/render/body.ts"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","length","err","Array","isArray","Object","TypeError","System","register","exports_1","context_1","renderBody","data","state","html","renderFragment","body","frag","lines","split","line","startsWith","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","word","parseWord","bit","test","parsePostLink","links","parseReference","parseURL","underscore_1","escape","num","parseInt","match","verified","etc_1","renderPostLink","board","op","name","href","refTargets","newTabLink","text","encodeURI","state_1","boards","id","setters","state_1_1","underscore_1_1","etc_1_1","execute","_state_1$config","config","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","enabled","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","psuedo","concat","_step3$value","link"],"mappings":"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","file":"posts/render/body.js","sourcesContent":["System.register(['../../state', 'underscore', './etc'], function(exports_1, context_1) {\n    \"use strict\";\n    var __moduleName = context_1 && context_1.id;\n    var state_1, underscore_1, etc_1;\n    var refTargets, boards;\n    function renderBody(data) {\n        if (!data.state) {\n            data.state = [0, 0, 0];\n        }\n        let html = renderFragment(data.body, data);\n        if (data.state[1]) {\n            html += '</em>';\n        }\n        if (data.state[2]) {\n            html += '</del>';\n        }\n        return html;\n    }\n    exports_1(\"renderBody\", renderBody);\n    function renderFragment(frag, data) {\n        const lines = frag.split('\\n'), { state } = data;\n        let html = '';\n        for (let i = 0; i < lines.length; i++) {\n            if (state[0] && i % 2) {\n                if (state[1] % 2) {\n                    html += '</em>';\n                    state[1]++;\n                }\n                html += '<br>';\n                state[0] = 0;\n            }\n            const line = lines[i];\n            if (!state[0] && line.startsWith('>')) {\n                html += '<em>';\n                state[1]++;\n            }\n            if (frag) {\n                for (let word of line.split(' ')) {\n                    html += parseWord(word, data);\n                    state[0] = 1;\n                }\n            }\n        }\n        return html;\n    }\n    exports_1(\"renderFragment\", renderFragment);\n    function parseWord(word, data) {\n        const split = word.split(/\\[\\/?spoiler]/i);\n        let html = '';\n        for (let i = 0; i < split.length; i++) {\n            if (i % 2) {\n                html += `<${data.state[2]++ % 2 ? '/' : ''}del>`;\n            }\n            const bit = split[i];\n            if (/^>>\\d+$/.test(bit)) {\n                html += parsePostLink(bit, data.links);\n            }\n            else if (/^>>>\\/\\w+\\//.test(bit)) {\n                html += parseReference(bit);\n            }\n            else if (/^https?:\\/\\/[^-A-Za-z0-9+&@#/%?=~_]$/.test(bit)) {\n                html += parseURL(bit);\n            }\n            else if (/<strong>.+<\\/strong>/.test(bit)) {\n                html += bit;\n            }\n            else {\n                html += underscore_1.escape(bit);\n            }\n        }\n        return html;\n    }\n    function parsePostLink(bit, links) {\n        if (!links) {\n            return bit;\n        }\n        const num = parseInt(bit.match(/^>>\\/(\\d+)$/)[1]), verified = links[num];\n        if (!verified) {\n            return bit;\n        }\n        return etc_1.renderPostLink(num, verified.board, verified.op);\n    }\n    function parseReference(bit) {\n        const name = bit.match(/^>>>\\/(\\w+)\\/$/)[1], href = refTargets[name];\n        if (!href) {\n            return bit;\n        }\n        return newTabLink(href, bit);\n    }\n    function newTabLink(href, text) {\n        return `<a href=\"${href}\" target=\"_blank\">${text}</a>`;\n    }\n    function parseURL(bit) {\n        return newTabLink(encodeURI(bit), bit);\n    }\n    return {\n        setters:[\n            function (state_1_1) {\n                state_1 = state_1_1;\n            },\n            function (underscore_1_1) {\n                underscore_1 = underscore_1_1;\n            },\n            function (etc_1_1) {\n                etc_1 = etc_1_1;\n            }],\n        execute: function() {\n            refTargets = {}, { boards } = state_1.config;\n            for (let board of boards.enabled) {\n                refTargets[board] = `../${board}/`;\n            }\n            for (let [name, link] of boards.psuedo.concat(boards.links)) {\n                refTargets[name] = link;\n            }\n        }\n    }\n});\n","import {config} from '../../state'\nimport {escape} from 'underscore'\nimport {renderPostLink} from './etc'\nimport {PostData, PostLinks} from '../models'\n\n// Render the text body of a post\nexport function renderBody(data: PostData): string {\n\tif (!data.state) {\n\t\t// Initial post state [new_line, no_qoute, no_spoiler]\n\t\tdata.state = [0, 0, 0]\n\t}\n\tlet html = renderFragment(data.body, data)\n\tif (data.state[1]) { // Close quote on post end\n\t\thtml += '</em>'\n\t}\n\tif (data.state[2]) { // Same with spoilers\n\t\thtml += '</del>'\n\t}\n\treturn html\n}\n\n// Parse commited text body fragment\nexport function renderFragment(frag: string, data: PostData): string {\n\tconst lines = frag.split('\\n'),\n\t\t{state} = data\n\tlet html = ''\n\tfor (let i = 0; i < lines.length; i++) {\n\t\t// Start a new line\n\t\tif (state[0] && i % 2) {\n\t\t\t// Close quoute\n\t\t\tif (state[1] % 2) {\n\t\t\t\thtml += '</em>'\n\t\t\t\tstate[1]++\n\t\t\t}\n\t\t\thtml += '<br>'\n\t\t\tstate[0] = 0\n\t\t}\n\n\t\t// Quote or line starts with link/embed\n\t\tconst line = lines[i]\n\t\tif (!state[0] && line.startsWith('>')) {\n\t\t\thtml += '<em>'\n\t\t\tstate[1]++\n\t\t}\n\n\t\t// Bodies may be empty\n\t\tif (frag) {\n\t\t\tfor (let word of line.split(' ')) {\n\t\t\t\thtml += parseWord(word, data)\n\t\t\t\tstate[0] = 1\n\t\t\t}\n\t\t}\n\t}\n\treturn html\n}\n\n// Convert a word to it's appropriate HTML representation\nfunction parseWord(word: string, data: PostData): string {\n\t// `[spoiler]` and `[/spoiler]` are treated the same way. You can't nest\n\t// them.\n\tconst split = word.split(/\\[\\/?spoiler]/i)\n\tlet html = ''\n\tfor (let i = 0; i < split.length; i++) {\n\t\t// Insert spoiler tags\n\t\tif (i % 2) {\n\t\t\thtml += `<${data.state[2]++ % 2 ? '/' : ''}del>`\n\n\t\t\t// TODO: Do we need special logic for postForms here?\n\t\t}\n\n\t\tconst bit = split[i]\n\t\tif (/^>>\\d+$/.test(bit)) {\n\t\t\t// Post links\n\t\t\thtml += parsePostLink(bit, data.links)\n\t\t} else if (/^>>>\\/\\w+\\//.test(bit)) {\n\t\t\t// Internal and custom reference URLs\n\t\t\thtml += parseReference(bit)\n\t\t} else if (/^https?:\\/\\/[^-A-Za-z0-9+&@#/%?=~_]$/.test(bit)) {\n\t\t\t// Generic URLs\n\t\t\thtml += parseURL(bit)\n\t\t} else if (/<strong>.+<\\/strong>/.test(bit)) {\n\t\t\t// Hash command results. Already verified server-side.\n\t\t\thtml += bit\n\t\t} else {\n\t\t\thtml += escape(bit)\n\t\t}\n\t}\n\treturn html\n}\n\n// Verify and render a link to other posts\nfunction parsePostLink(bit: string, links: PostLinks): string {\n\tif (!links) {\n\t\treturn bit\n\t}\n\tconst num = parseInt(bit.match(/^>>\\/(\\d+)$/)[1]),\n\t\tverified = links[num]\n\tif (!verified) {\n\t\treturn bit\n\t}\n\treturn renderPostLink(num, verified.board, verified.op)\n}\n\n// Generate all possible refference name and link pairs\nconst refTargets: {[ref: string]: string} = {},\n\t{boards} = config\nfor (let board of boards.enabled) {\n\trefTargets[board] = `../${board}/`\n}\nfor (let [name, link] of boards.psuedo.concat(boards.links)) {\n\trefTargets[name] = link\n}\n\n// Parse internal or customly set reference URL\nfunction parseReference(bit: string): string {\n\tconst name = bit.match(/^>>>\\/(\\w+)\\/$/)[1],\n\t\thref = refTargets[name]\n\tif (!href) {\n\t\treturn bit\n\t}\n\treturn newTabLink(href, bit)\n}\n\n// Render and anchor link that opens in a new tab\nfunction newTabLink(href: string, text: string): string {\n\treturn `<a href=\"${href}\" target=\"_blank\">${text}</a>`\n}\n\n// Render generic URLs and embed, if aplicable\nfunction parseURL(bit: string): string {\n\n\t// TODO: Embeds\n\n\treturn newTabLink(encodeURI(bit), bit)\n}\n"],"sourceRoot":"/source/"}