{"version":3,"sources":["connection.js","connection.ts"],"names":["System","register","exports_1","context_1","send","msg","connSM","state","socket","readyState","console","warn","state_1","debug","log","onMessage","_ref","data","handler","handlers","slice","renderStatus","status","syncEl","textContent","lang_1","sync","connect","nullSocket","window","location","protocol","error","WebSocket","path","binaryType","onopen","feeder","onclose","onmessage","onerror","onError","err","resetAttempts","attemptTimer","clearTimeout","attempts","start","feed","onWindowFocus","navigator","onLine","fsm_1","message","id","setters","fsm_1_1","state_1_1","lang_1_1","execute","document","getElementById","act","host","setTimeout","wildAct","wait","Math","pow","min","floor","addEventListener","event","target","hidden"],"mappings":"AAAA,YAAAA,QAAOC,UAAU,QAAS,UAAW,UAAW,SAASC,EAAWC,GCwCpE,QAAAC,GAAqBC,GACpB,GAAqB,IAAjBC,EAAOC,OACU,IAAjBD,EAAOC,MADX,CAKA,GAA0B,IAAtBC,EAAOC,WAEV,WADAC,SAAQC,KAAK,yCAGVC,GAAAC,OACHH,QAAQI,IAAI,IAAKT,GAElBG,EAAOJ,KAAKC,IAIb,QAAAU,GAAAC,GDlCQ,GCkCYC,GAAID,EAAJC,IACfL,GAAAC,OACHH,QAAQI,IAAI,IAAKG,EAElB,IAAMC,GAAUC,EAASF,EAAK,GAC1BC,IACHA,EAAQD,EAAKG,MAAM,IAOrB,QAAAC,GAAsBC,GACrBC,EAAOC,YAAcC,EAAAC,KAAKJ,GAY3B,QAAAK,KAEC,MADAC,KACgC,SAA5BC,OAAOC,SAASC,aACnBrB,SAAQsB,MAAM,+CAGfxB,EAAS,GAAIyB,WAAUC,GACvB1B,EAAO2B,WAAa,cACpB3B,EAAO4B,OAAS9B,EAAO+B,OAAO,GAC9B7B,EAAO8B,QAAUhC,EAAO+B,OAAO,GAC/B7B,EAAO+B,UAAYxB,EACnBP,EAAOgC,QAAUC,OACb7B,EAAAC,QACFgB,OAAerB,OAASA,KAI3B,QAAAiC,GAAiBC,GAChBhC,QAAQsB,MAAMU,GAIf,QAAAd,KACKpB,IACHA,EAAO8B,QACJ9B,EAAO+B,UACP/B,EAAO4B,OACP5B,EAAO8B,QACP9B,EAAOgC,QACP,MAeL,QAAAG,KACKC,IACHC,aAAaD,GACbA,EAAe,GAEhBE,EAAW,EAiCZ,QAAAC,KACCzC,EAAO0C,KAAK,GAKb,QAAAC,KACsB,IAAjB3C,EAAOC,OAAgC2C,UAAUC,QACpD7C,EAAO0C,KAAK,GD3KV,GACII,GAAOxC,EAASa,ECMX4B,EAQAlC,EAgBAb,EAETE,EACHsC,EACAF,EA8BKrB,EAaAW,CD9EiB/B,IAAaA,EAAUmD,EA2E1C,OCrCJpD,GAAA,OAAAE,GA6HAF,EAAA,QAAA6C,IDvFQQ,SACI,SAAUC,GACNJ,EAAQI,GAEZ,SAAUC,GACN7C,EAAU6C,GAEd,SAAUC,GACNjC,EAASiC,IAEjBC,QAAS,WC/EJzD,EAAA,UAAAmD,MAQAnD,EAAA,WAAAiB,MAgBAjB,EAAA,SAAAI,EAAS,GAAI8C,GAAAA,WAA0B,IAkC9C7B,EAASqC,SAASC,eAAe,QAOvCvD,EAAOwD,KAAK,GAAoB,EAAiB,EAAsB,WACtEzC,EAAa,GACbyB,EAAW,EACXnB,MAGKO,GAA8B,UAAtBJ,SAASC,SAAuB,MAAQ,OAAI,MACjDD,SAASiC,KAAI,WAmCtBzD,EAAOwD,KACL,EAAsB,GACvB,EACA,EACA,WACCzC,EAAa,GACbuB,EAAeoB,WAAW,WDxBR,MCwBcrB,MAAiB,OAanDrC,EAAO2D,QAAQ,EAAiB,EAAmB,SAAAvB,GAClDd,IACIhB,EAAAC,OACHH,QAAQsB,MAAMU,GAEXE,IACHC,aAAaD,GACbA,EAAe,GAEhBvB,EAAa,EAGb,IAAM6C,GAAO,IAAMC,KAAKC,IACvB,IACAD,KAAKE,IAAIF,KAAKG,QAAQxB,EAAW,GAAI,IAEtCkB,YAAW1D,EAAO+B,OAAO,GAAkB6B,KAG5C5D,EAAOwD,KAAK,GAAoB,EAAiB,EAAwB,WACxEnC,IAGAqC,WAAW,WACW,IAAjB1D,EAAOC,OACVc,EAAa,IAEZ,OAeJuC,SAASW,iBAAiB,mBAAoB,SAAAC,GACvCA,EAAMC,OAAoBC,QAC/BzB,MAIFpB,OAAO0C,iBAAiB,SAAU,WACjC5B,IACArC,EAAO0C,KAAK,KAEbnB,OAAO0C,iBAAiB,UAAWjE,EAAO+B,OAAO","file":"connection.js","sourcesContent":["System.register(['./fsm', './state', './lang'], function(exports_1, context_1) {\n    \"use strict\";\n    var __moduleName = context_1 && context_1.id;\n    var fsm_1, state_1, lang_1;\n    var message, handlers, connSM, socket, attempts, attemptTimer, syncEl, path;\n    function send(msg) {\n        if (connSM.state !== 3\n            && connSM.state !== 2) {\n            return;\n        }\n        if (socket.readyState !== 1) {\n            console.warn(\"Attempting to send while socket closed\");\n            return;\n        }\n        if (state_1.debug) {\n            console.log('<', msg);\n        }\n        socket.send(msg);\n    }\n    exports_1(\"send\", send);\n    function onMessage({ data }) {\n        if (state_1.debug) {\n            console.log('>', data);\n        }\n        const handler = handlers[data[0]];\n        if (handler) {\n            handler(data.slice(1));\n        }\n    }\n    function renderStatus(status) {\n        syncEl.textContent = lang_1.sync[status];\n    }\n    function connect() {\n        nullSocket();\n        if (window.location.protocol == 'file:') {\n            console.error(\"Page downloaded locally. Refusing to sync.\");\n            return;\n        }\n        socket = new WebSocket(path);\n        socket.binaryType = \"arraybuffer\";\n        socket.onopen = connSM.feeder(1);\n        socket.onclose = connSM.feeder(2);\n        socket.onmessage = onMessage;\n        socket.onerror = onError;\n        if (state_1.debug) {\n            window.socket = socket;\n        }\n    }\n    function onError(err) {\n        console.error(err);\n    }\n    function nullSocket() {\n        if (socket) {\n            socket.onclose\n                = socket.onmessage\n                    = socket.onopen\n                        = socket.onclose\n                            = socket.onerror\n                                = null;\n        }\n    }\n    function resetAttempts() {\n        if (attemptTimer) {\n            clearTimeout(attemptTimer);\n            attemptTimer = 0;\n        }\n        attempts = 0;\n    }\n    function start() {\n        connSM.feed(0);\n    }\n    exports_1(\"start\", start);\n    function onWindowFocus() {\n        if (connSM.state !== 6 && navigator.onLine) {\n            connSM.feed(3);\n        }\n    }\n    return {\n        setters:[\n            function (fsm_1_1) {\n                fsm_1 = fsm_1_1;\n            },\n            function (state_1_1) {\n                state_1 = state_1_1;\n            },\n            function (lang_1_1) {\n                lang_1 = lang_1_1;\n            }],\n        execute: function() {\n            exports_1(\"message\", message = {});\n            exports_1(\"handlers\", handlers = {});\n            exports_1(\"connSM\", connSM = new fsm_1.default(0));\n            syncEl = document.getElementById('sync');\n            connSM.act([0], 0, 1, () => {\n                renderStatus(1);\n                attempts = 0;\n                connect();\n            });\n            path = (location.protocol === 'https' ? 'wss' : 'ws')\n                + `://${location.host}/socket`;\n            connSM.act([1, 4], 1, 2, () => {\n                renderStatus(1);\n                attemptTimer = setTimeout(() => resetAttempts(), 10000);\n            });\n            connSM.wildAct(2, 5, err => {\n                nullSocket();\n                if (state_1.debug) {\n                    console.error(err);\n                }\n                if (attemptTimer) {\n                    clearTimeout(attemptTimer);\n                    attemptTimer = 0;\n                }\n                renderStatus(0);\n                const wait = 500 * Math.pow(1.5, Math.min(Math.floor(++attempts / 2), 12));\n                setTimeout(connSM.feeder(3), wait);\n            });\n            connSM.act([5], 3, 4, () => {\n                connect();\n                setTimeout(() => {\n                    if (connSM.state === 4) {\n                        renderStatus(1);\n                    }\n                }, 100);\n            });\n            document.addEventListener('visibilitychange', event => {\n                if (!event.target.hidden) {\n                    onWindowFocus();\n                }\n            });\n            window.addEventListener('online', () => {\n                resetAttempts();\n                connSM.feed(3);\n            });\n            window.addEventListener('offline', connSM.feeder(2));\n        }\n    }\n});\n","/*\n Handles Websocket connectivity\n*/\n\nimport FSM from './fsm'\nimport {debug} from './state'\nimport {sync as lang} from './lang'\n\n// Message types of the WebSocket communication protocol\nexport const message: {[type: string]: number} = {\n\n}\n\nexport type MessageHandler = (data: ArrayBuffer) => void\n\n// Websocket message handlers. Each handler responds to its distinct message\n// type.\nexport const handlers: {[type: number]: MessageHandler} = {}\n\n// Websocket connection and syncronisation with server states\nconst enum syncStatus {disconnected, connecting, syncing, synced, desynced}\n\n// States of the connection finite state machine\nexport const enum connState {\n\tloading, connecting, syncing, synced, reconnecting, dropped, desynced\n}\n\n// Events passable to the connection FSM\nexport const enum connEvent {\n\tstart, open, close, retry, error\n}\n\n// Finite state machine for managing websocket connectivity\nexport const connSM = new FSM<connState, connEvent>(connState.loading)\n\nlet socket: WebSocket,\n\tattempts: number,\n\tattemptTimer: number\n\n// Send a message to the server\nexport function send(msg: ArrayBuffer) {\n\tif (connSM.state !== connState.synced\n\t\t&& connSM.state !== connState.syncing\n\t) {\n\t\treturn\n\t}\n\tif (socket.readyState !== 1) {\n\t\tconsole.warn(\"Attempting to send while socket closed\")\n\t\treturn\n\t}\n\tif (debug) {\n\t\tconsole.log('<', msg)\n\t}\n\tsocket.send(msg)\n}\n\n// Routes messages from the server to the respective handler\nfunction onMessage({data}: MessageEvent) {\n\tif (debug) {\n\t\tconsole.log('>', data)\n\t}\n\tconst handler = handlers[data[0]]\n\tif (handler) {\n\t\thandler(data.slice(1))\n\t}\n}\n\nconst syncEl = document.getElementById('sync')\n\n// Render connction status indicator\nfunction renderStatus(status: syncStatus) {\n\tsyncEl.textContent = lang[status]\n}\n\nconnSM.act([connState.loading], connEvent.start, connState.connecting, () => {\n\trenderStatus(syncStatus.connecting)\n\tattempts = 0\n\tconnect()\n})\n\nconst path = (location.protocol === 'https' ? 'wss' : 'ws')\n\t+ `://${location.host}/socket`\n\nfunction connect() {\n\tnullSocket()\n\tif (window.location.protocol == 'file:') {\n\t\tconsole.error(\"Page downloaded locally. Refusing to sync.\")\n\t\treturn\n\t}\n\tsocket = new WebSocket(path)\n\tsocket.binaryType = \"arraybuffer\"\n\tsocket.onopen = connSM.feeder(connEvent.open)\n\tsocket.onclose = connSM.feeder(connEvent.close)\n\tsocket.onmessage = onMessage\n\tsocket.onerror = onError\n\tif (debug) {\n\t\t(window as any).socket = socket\n\t}\n}\n\nfunction onError(err: Event) {\n\tconsole.error(err)\n}\n\n// Strip all handlers and remove references from Websocket instance\nfunction nullSocket() {\n\tif (socket) {\n\t\tsocket.onclose\n\t\t\t= socket.onmessage\n\t\t\t= socket.onopen\n\t\t\t= socket.onclose\n\t\t\t= socket.onerror\n\t\t\t= null\n\t}\n}\n\nconnSM.act(\n\t[connState.connecting, connState.reconnecting],\n\tconnEvent.open,\n\tconnState.syncing,\n\t() => {\n\t\trenderStatus(syncStatus.connecting)\n\t\tattemptTimer = setTimeout(() => resetAttempts(), 10000)\n\t}\n)\n\n// Reset the reconnection attempt counter and timers\nfunction resetAttempts() {\n\tif (attemptTimer) {\n\t\tclearTimeout(attemptTimer)\n\t\tattemptTimer = 0\n\t}\n\tattempts = 0\n}\n\nconnSM.wildAct(connEvent.close, connState.dropped, err => {\n\tnullSocket()\n\tif (debug) {\n\t\tconsole.error(err)\n\t}\n\tif (attemptTimer) {\n\t\tclearTimeout(attemptTimer)\n\t\tattemptTimer = 0\n\t}\n\trenderStatus(syncStatus.disconnected)\n\n\t// Wait maxes out at ~1min\n\tconst wait = 500 * Math.pow(\n\t\t1.5,\n\t\tMath.min(Math.floor(++attempts / 2), 12)\n\t)\n\tsetTimeout(connSM.feeder(connEvent.retry), wait)\n})\n\nconnSM.act([connState.dropped], connEvent.retry, connState.reconnecting, () => {\n\tconnect()\n\n\t// Don't show this immediately so we don't thrash on network loss\n\tsetTimeout(() => {\n\t\tif (connSM.state === connState.reconnecting) {\n\t\t\trenderStatus(syncStatus.connecting)\n\t\t}\n\t}, 100)\n})\n\nexport function start() {\n\tconnSM.feed(connEvent.start)\n}\n\n// Work arround browser slowing down/suspending tabs and keep the FSM up to date\n// with the actual status.\nfunction onWindowFocus() {\n\tif (connSM.state !== connState.desynced && navigator.onLine) {\n\t\tconnSM.feed(connEvent.retry)\n\t}\n}\n\ndocument.addEventListener('visibilitychange', event => {\n\tif (!(event.target as Document).hidden) {\n\t\tonWindowFocus()\n\t}\n})\n\nwindow.addEventListener('online', () => {\n\tresetAttempts()\n\tconnSM.feed(connEvent.retry)\n})\nwindow.addEventListener('offline', connSM.feeder(connEvent.close))\n"],"sourceRoot":"/source/"}